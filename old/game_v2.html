<!DOCTYPE html>
<html>
<head>
<title>Project: GLITCHFALL [Fixed]</title>
<meta charset="UTF-8">
<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<style>
	body, html {
		margin: 0;
		padding: 0;
		overflow: hidden;
		background-color: #0a0a1a;
		height: 100%;
		width: 100%;
	}

	#game-container {
		position: relative;
		width: 100%;
		height: 100%;
		cursor: crosshair;
	}

	canvas {
		display: block;
		position: absolute;
		top: 0;
		left: 0;
	}
	
	#background-canvas {
		z-index: 0;
		background-color: #0a0a1a;
	}

	#main-canvas {
		z-index: 1;
		background-color: transparent;
	}

	#hud {
		position: absolute;
		top: 10px;
		left: 10px;
		color: #00ffff;
		font-family: 'Courier New', Courier, monospace;
		font-size: 20px;
		z-index: 2;
		text-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff;
	}

	#dash-cooldown {
		position: absolute;
		bottom: 20px;
		left: 50%;
		transform: translateX(-50%);
		width: 100px;
		height: 20px;
		border: 2px solid #00ffff;
		background-color: rgba(0, 0, 0, 0.5);
		z-index: 2;
	}
	
	#dash-indicator {
		height: 100%;
		width: 100%;
		background-color: #00ffff;
		transition: width 0.1s linear;
	}
	
	.game-screen {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		display: flex;
		flex-direction: column;
		justify-content: center;
		align-items: center;
		background-color: rgba(0, 0, 0, 0.8);
		color: #00ffff;
		font-family: 'Courier New', Courier, monospace;
		z-index: 10;
		text-align: center;
		cursor: pointer;
	}
	
	.game-screen h1 {
		font-size: 4em;
		text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
		margin-bottom: 20px;
	}

	.game-screen p {
		font-size: 1.5em;
	}

	#upgrade-screen .upgrade-option {
		border: 2px solid #00ffff;
		padding: 20px;
		margin: 10px;
		cursor: pointer;
		width: 80%;
		max-width: 500px;
		transition: background-color 0.2s, box-shadow 0.2s;
	}

	#upgrade-screen .upgrade-option:hover {
		background-color: rgba(0, 255, 255, 0.2);
		box-shadow: 0 0 15px #00ffff;
	}
</style>
</head>
<body>
<div id="game-container">
    <canvas id="background-canvas"></canvas>
    <canvas id="main-canvas"></canvas>
    
    <div id="hud" style="display: none;">
        <div>Score: <span id="score">0</span></div>
        <div>Data Shards: <span id="shards">0</span></div>
        <div>Health: <span id="health">3</span></div>
    </div>

    <div id="dash-cooldown" style="display: none;">
        <div id="dash-indicator"></div>
    </div>

    <div id="start-screen" class="game-screen">
        <h1>PROJECT: GLITCHFALL</h1>
        <p>Click to Begin Run</p>
    </div>

    <div id="upgrade-screen" class="game-screen" style="display: none;">
        <h1>SECTOR COMPLETE</h1>
        <p>Select a Volatile Mod:</p>
        <div id="upgrade-options"></div>
    </div>
    
    <div id="game-over-screen" class="game-screen" style="display: none;">
        <h1>SYSTEM CRASH!</h1>
        <p>Score: <span id="final-score">0</span></p>
        <p>Best Score: <span id="best-score">0</span></p>
        <p>System Restoration Points: <span id="permanent-currency">0</span></p>
        <p>Press 'R' to Reboot</p>
    </div>

</div>

<script>
// --- Matter.js Aliases ---
const { Engine, Render, Runner, World, Bodies, Body, Events, Composite, Vector, SAT } = Matter;

// --- DOM Elements ---
const gameContainer = document.getElementById('game-container');
const mainCanvas = document.getElementById('main-canvas');
const bgCanvas = document.getElementById('background-canvas');
const mainCtx = mainCanvas.getContext('2d');
const bgCtx = bgCanvas.getContext('2d');

// --- Engine and World ---
let engine, world, runner;

// --- Game Objects ---
let player;
let exitPortal;
let particles = [];
let projectiles = [];
let enemies = [];
let unstableBlocks = [];
let shards = [];
let staticBodies = []; // For optimized rendering

// --- Game State and Config ---
let gameState = 'start'; // 'start', 'playing', 'upgrade', 'gameOver'
let lastTime = 0;
let gameFrame = 0;

const config = {
    player: {
        width: 30,
        height: 55,
        speed: 7,
        airControlFactor: 0.6,
        jumpForce: 13,
        dashSpeed: 20,
        dashDuration: 150, // ms
        dashInvincibilityDuration: 300, // ms
        dashCooldown: 1000, // ms
        wallSlideSpeed: 1.5,
        wallJumpForce: { x: 8, y: 11 },
    },
    world: {
        gravity: 1.2,
        width: 4000,
        height: 2000,
    },
    camera: {
        lerp: 0.08,
        zoom: 1.0,
        targetZoom: 1.0,
        zoomSpeed: 0.01,
    }
};

// --- Camera and Stats ---
let camera;
let score = 0;
let dataShards = 0;
let sector = 1;
let bestScore = localStorage.getItem('glitchfall_bestScore') || 0;
let permanentCurrency = localStorage.getItem('glitchfall_permCurrency') || 0;

// --- Player Stats & Upgrades ---
let playerState = {
    health: 3,
    maxHealth: 3,
    jumpsLeft: 0,
    dashCharges: 1,
    lastDashTime: 0,
    isDashing: false,
    isInvincible: false,
    isGrounded: false,
    isWallSliding: false,
    wallSlideDirection: 0,
    // Upgrades
    maxJumps: 3,
    maxDashCharges: 1,
    lanceBounces: 0,
    volatileExplosionSize: 1.0,
    strongerWallJumps: 1.0,
    enemiesExplodeOnDeath: false,
};

const allUpgrades = [
    { id: 'lanceBounce', text: 'Data Lance bounces off walls 3 times.', apply: () => playerState.lanceBounces = 3 },
    { id: 'doubleDash', text: 'Gain a second Dash charge.', apply: () => playerState.maxDashCharges = 2 },
    { id: 'bigBoom', text: 'Volatile Block explosions are 50% larger.', apply: () => playerState.volatileExplosionSize = 1.5 },
    { id: 'wallBoost', text: 'Wall-jumps are 30% stronger.', apply: () => playerState.strongerWallJumps = 1.3 },
    { id: 'enemyExplode', text: 'Enemies have a 25% chance to explode on death.', apply: () => playerState.enemiesExplodeOnDeath = true },
    { id: 'quadJump', text: 'Gain an extra mid-air jump.', apply: () => playerState.maxJumps = 4 }
];

// --- Input Handling ---
const keys = {};
const mouse = { x: 0, y: 0, isDown: false };


// --- UTILITY FUNCTIONS ---
function drawBody(ctx, body) {
    const vertices = body.vertices;
    ctx.beginPath();
    ctx.moveTo(vertices[0].x, vertices[0].y);
    for (let j = 1; j < vertices.length; j++) {
        ctx.lineTo(vertices[j].x, vertices[j].y);
    }
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
}

// --- INITIALIZATION ---
function init() {
    engine = Engine.create();
    world = engine.world;
    world.gravity.y = config.world.gravity;
    runner = Runner.create();
    
    camera = { x: 0, y: 0, zoom: config.camera.zoom, shakeDuration: 0, shakeMagnitude: 0 };
    
    resizeCanvases();
    window.addEventListener('resize', resizeCanvases);
    
    setupInputListeners();
    setupCollisionEvents();
    
    Runner.run(runner, engine);
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
    
    document.getElementById('start-screen').addEventListener('click', startGameRun, { once: true });
}

function startGameRun() {
    // Reset world and objects
    World.clear(world, false);
    particles = [];
    projectiles = [];
    enemies = [];
    unstableBlocks = [];
    shards = [];
    staticBodies = [];
    
    // Reset player state and stats
    resetPlayerStatsForNewRun();
    createPlayer(200, config.world.height - 200);
    
    score = 0;
    dataShards = 0;
    sector = 1;
    
    generateSector(sector);
    
    // Update UI
    document.getElementById('hud').style.display = 'block';
    document.getElementById('dash-cooldown').style.display = 'block';
    document.getElementById('start-screen').style.display = 'none';
    document.getElementById('game-over-screen').style.display = 'none';
    
    gameState = 'playing';
}

function resetPlayerStatsForNewRun() {
    playerState.health = playerState.maxHealth;
    playerState.maxJumps = 3;
    playerState.maxDashCharges = 1;
    playerState.lanceBounces = 0;
    playerState.volatileExplosionSize = 1.0;
    playerState.strongerWallJumps = 1.0;
    playerState.enemiesExplodeOnDeath = false;
    
    playerState.jumpsLeft = playerState.maxJumps;
    playerState.dashCharges = playerState.maxDashCharges;
    playerState.lastDashTime = 0;
}

// --- MAIN GAME LOOP ---
function gameLoop(currentTime) {
    const deltaTime = (currentTime - lastTime) || (1000 / 60);
    lastTime = currentTime;

    if (gameState === 'playing') {
        handlePlayerInput(deltaTime);
        update(deltaTime);
    }
    
    updateCamera(deltaTime);
    render(deltaTime);
    
    gameFrame++;
    requestAnimationFrame(gameLoop);
}

function update(dt) {
    if (!player) return;
    updatePlayerState();
    updateProjectiles(dt);
    updateEnemies(dt);
    updateParticles(dt);
    updateShards(dt);
    updateUnstableBlocks(dt);
    checkPortalCollision();
    
    if (player.body.position.y > config.world.height + 200) {
        gameOver();
    }
}


// --- RENDERING ---
function render() {
    mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
    mainCtx.save();
    
    let camX = camera.x;
    let camY = camera.y;
    if (camera.shakeDuration > 0) {
        camX += (Math.random() - 0.5) * camera.shakeMagnitude;
        camY += (Math.random() - 0.5) * camera.shakeMagnitude;
        camera.shakeDuration--;
    }
    mainCtx.translate(mainCanvas.width / 2, mainCanvas.height / 2);
    mainCtx.scale(camera.zoom, camera.zoom);
    mainCtx.translate(-camX, -camY);

    mainCtx.strokeStyle = '#557';
    mainCtx.fillStyle = '#1a1a2a';
    mainCtx.lineWidth = 2;
    staticBodies.forEach(body => drawBody(mainCtx, body));

    unstableBlocks.forEach(renderUnstableBlock);
    
    shards.forEach(renderShard);
    projectiles.forEach(renderProjectile);
    enemies.forEach(renderEnemy);
    if(player) renderPlayer();
    if(exitPortal) renderPortal();
    particles.forEach(renderParticle);

    mainCtx.restore();
    
    updateHUD();
}

function renderPlayer() {
    const pos = player.body.position;
    const w = config.player.width;
    const h = config.player.height;
    
    mainCtx.save();
    mainCtx.translate(pos.x, pos.y);
    
    if (playerState.isInvincible) mainCtx.globalAlpha = 0.5 + Math.sin(performance.now() * 0.05) * 0.2;
    
    mainCtx.fillStyle = '#00ffff';
    mainCtx.shadowColor = '#00ffff';
    mainCtx.shadowBlur = 15;
    
    mainCtx.fillRect(-w/2, -h/2, w, h);
    
    mainCtx.restore();
    
    if (Vector.magnitude(player.body.velocity) > 1) {
         createParticle(pos.x, pos.y, '#00ffff', 2, 1, 0, 0, 20);
    }
}

function renderUnstableBlock(block) {
    const pos = block.body.position;
    const w = block.width;
    const h = block.height;
    
    mainCtx.save();
    mainCtx.translate(pos.x, pos.y);
    mainCtx.rotate(block.body.angle);
    
    mainCtx.lineWidth = 2;

    switch(block.type) {
        case 'fragile':
            mainCtx.fillStyle = '#888';
            mainCtx.strokeStyle = '#AAA';
            mainCtx.fillRect(-w/2, -h/2, w, h);
            mainCtx.beginPath();
            mainCtx.moveTo(-w/4, -h/2); mainCtx.lineTo(w/4, h/2);
            mainCtx.moveTo(w/3, -h/3); mainCtx.lineTo(-w/3, h/4);
            mainCtx.strokeStyle = '#444';
            mainCtx.stroke();
            break;
        case 'volatile':
            const pulse = Math.sin(gameFrame * 0.05) * 5 + 5;
            mainCtx.fillStyle = block.isTriggered ? '#ff5500' : '#ffae42';
            mainCtx.strokeStyle = '#ffae42';
            mainCtx.shadowColor = '#ffae42';
            mainCtx.shadowBlur = pulse;
            mainCtx.fillRect(-w/2, -h/2, w, h);
            if (block.isTriggered) {
                const flashAlpha = Math.abs(Math.sin(gameFrame * 0.5));
                mainCtx.fillStyle = `rgba(255, 255, 255, ${flashAlpha})`;
                mainCtx.fillRect(-w/2, -h/2, w, h);
            }
            break;
        case 'kinetic':
            mainCtx.fillStyle = '#8a2be2';
            mainCtx.strokeStyle = '#c07cfc';
            mainCtx.fillRect(-w/2, -h/2, w, h);
            mainCtx.strokeStyle = '#f0f';
            mainCtx.lineWidth = 4;
            for(let i = -1; i <= 1; i+=2) {
                mainCtx.beginPath();
                mainCtx.moveTo(-w/4, i * h/4);
                mainCtx.lineTo(0, 0);
                mainCtx.lineTo(w/4, i * h/4);
                mainCtx.stroke();
            }
            break;
    }
    mainCtx.restore();
}

function renderEnemy(enemy) {
    if (!enemy.body) return;
    const pos = enemy.body.position;
    mainCtx.save();
    mainCtx.translate(pos.x, pos.y);
    mainCtx.rotate(enemy.body.angle);

    // Change color based on state for visual feedback
    if (enemy.state === 'chasing') {
        mainCtx.fillStyle = '#ff5555'; // More intense red when chasing
        mainCtx.strokeStyle = '#ff9999';
        mainCtx.shadowColor = '#ff3333';
    } else {
        mainCtx.fillStyle = '#ff3030'; // Standard red
        mainCtx.strokeStyle = '#ff8080';
        mainCtx.shadowColor = '#ff0000';
    }
    
    mainCtx.shadowBlur = 10;
    mainCtx.lineWidth = 2;

    drawBody(mainCtx, enemy.body);
    mainCtx.restore();
}

function renderProjectile(p) {
    if(p.isEnemy) {
        mainCtx.fillStyle = '#ff8000';
        mainCtx.shadowColor = '#ff8000';
    } else {
        mainCtx.fillStyle = '#90ee90';
        mainCtx.shadowColor = '#90ee90';
    }
    mainCtx.shadowBlur = 10;
    drawBody(mainCtx, p.body);
    createParticle(p.body.position.x, p.body.position.y, mainCtx.fillStyle, 1, 0.5);
}

function renderParticle(p) {
    mainCtx.fillStyle = p.color;
    mainCtx.globalAlpha = p.life / p.maxLife;
    mainCtx.beginPath();
    mainCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    mainCtx.fill();
    mainCtx.globalAlpha = 1;
}

function renderShard(s) {
    const pos = s.body.position;
    mainCtx.save();
    mainCtx.translate(pos.x, pos.y);
    const pulse = Math.sin(gameFrame * 0.1 + s.body.id) * 0.2 + 0.8;
    mainCtx.scale(pulse, pulse);
    mainCtx.fillStyle = '#00ffff';
    mainCtx.shadowColor = '#00ffff';
    mainCtx.shadowBlur = 10;
    mainCtx.beginPath();
    mainCtx.moveTo(0, -7);
    mainCtx.lineTo(6, 6);
    mainCtx.lineTo(-6, 6);
    mainCtx.closePath();
    mainCtx.fill();
    mainCtx.restore();
}

function renderPortal() {
    const pos = exitPortal.body.position;
    mainCtx.save();
    mainCtx.translate(pos.x, pos.y);
    const angle = gameFrame * 0.01;
    const size = exitPortal.radius;

    for(let i=0; i < 3; i++) {
        const radius = size * (1 - i*0.2) * (Math.sin(gameFrame * 0.02 + i) * 0.1 + 0.9);
        mainCtx.strokeStyle = `rgba(138, 43, 226, ${1 - i*0.2})`;
        mainCtx.lineWidth = 4 - i;
        mainCtx.beginPath();
        mainCtx.arc(0, 0, radius, 0, Math.PI*2);
        mainCtx.stroke();
    }
    mainCtx.restore();
}

function drawBackground() {
    bgCtx.fillStyle = '#0a0a1a';
    bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
    bgCtx.strokeStyle = 'rgba(0, 255, 255, 0.05)';
    const gridSize = 50;
    const parallaxX = (camera.x * 0.1) % gridSize;
    const parallaxY = (camera.y * 0.1) % gridSize;

    for (let x = -parallaxX; x < bgCanvas.width; x += gridSize) {
        bgCtx.beginPath();
        bgCtx.moveTo(x, 0);
        bgCtx.lineTo(x, bgCanvas.height);
        bgCtx.stroke();
    }
    for (let y = -parallaxY; y < bgCanvas.height; y += gridSize) {
        bgCtx.beginPath();
        bgCtx.moveTo(0, y);
        bgCtx.lineTo(bgCanvas.width, y);
        bgCtx.stroke();
    }
}


// --- PLAYER LOGIC ---
function createPlayer(x, y) {
    const pConfig = config.player;
    const core = Bodies.rectangle(x, y, pConfig.width, pConfig.height, { 
        label: 'player-core', 
        inertia: Infinity,
        friction: 0.05,
        restitution: 0.1 
    });
    const groundSensor = Bodies.rectangle(x, y + pConfig.height / 2, pConfig.width - 4, 10, { 
        isSensor: true, 
        label: 'player-ground-sensor' 
    });
    const leftSensor = Bodies.rectangle(x - pConfig.width / 2, y, 10, pConfig.height - 8, { 
        isSensor: true, 
        label: 'player-left-sensor' 
    });
    const rightSensor = Bodies.rectangle(x + pConfig.width / 2, y, 10, pConfig.height - 8, { 
        isSensor: true, 
        label: 'player-right-sensor' 
    });

    player = {
        body: Body.create({
            parts: [core, groundSensor, leftSensor, rightSensor],
            label: 'player'
        }),
        groundSensor,
        leftSensor,
        rightSensor,
        core,
        contactPoints: { ground: false, left: false, right: false },
    };
    World.add(world, player.body);
}

function handlePlayerInput() {
    if (!player) return;

    let targetVelX = 0;
    if (keys['KeyD'] || keys['ArrowRight']) targetVelX = config.player.speed;
    if (keys['KeyA'] || keys['ArrowLeft']) targetVelX = -config.player.speed;
    
    const airControl = playerState.isGrounded ? 1 : config.player.airControlFactor;
    const newVelX = player.body.velocity.x + (targetVelX - player.body.velocity.x) * 0.2 * airControl;
    Body.setVelocity(player.body, { x: newVelX, y: player.body.velocity.y });

    if (keys['ShiftLeft'] && !playerState.isDashing) {
        const now = performance.now();
        if (now - playerState.lastDashTime > config.player.dashCooldown && playerState.dashCharges > 0) {
            playerState.isDashing = true;
            playerState.isInvincible = true;
            playerState.lastDashTime = now;
            playerState.dashCharges--;

            let dashDir = targetVelX !== 0 ? Math.sign(targetVelX) : (player.body.velocity.x >= 0 ? 1 : -1);
            if (dashDir === 0) dashDir = 1;

            Body.setVelocity(player.body, { x: config.player.dashSpeed * dashDir, y: 0 });
            
            for(let i=0; i<20; i++) createParticle(player.body.position.x, player.body.position.y, '#FFFFFF', 3, 2);

            setTimeout(() => {
                playerState.isDashing = false;
                if(player) Body.setVelocity(player.body, { x: player.body.velocity.x * 0.2, y: player.body.velocity.y });
            }, config.player.dashDuration);
            setTimeout(() => playerState.isInvincible = false, config.player.dashInvincibilityDuration);
        }
    }
}

function onKeyDown(e) {
    if (gameState !== 'playing' || !player) return;
    
    if (e.code === 'Space' || e.code === 'KeyW' || e.code === 'ArrowUp') {
        if (playerState.isWallSliding) {
            const forceX = playerState.wallSlideDirection * config.player.wallJumpForce.x * playerState.strongerWallJumps;
            const forceY = -config.player.wallJumpForce.y * playerState.strongerWallJumps;
            Body.setVelocity(player.body, { x: forceX, y: forceY });
            playerState.jumpsLeft = playerState.maxJumps - 1;
            playerState.isWallSliding = false;
            for(let i=0; i<15; i++) createParticle(player.body.position.x, player.body.position.y, '#00ffff', 4, 3);
        } else if (playerState.jumpsLeft > 0) {
            Body.setVelocity(player.body, { x: player.body.velocity.x, y: -config.player.jumpForce });
            playerState.jumpsLeft--;
            for(let i=0; i<10; i++) createParticle(player.body.position.x, player.body.position.y, '#00ffff', 3, 2);
        }
    }
}

function onMouseClick() {
     if (gameState === 'playing' && player) {
        shoot();
     }
}

function updatePlayerState() {
    const now = performance.now();

    if (now - playerState.lastDashTime > config.player.dashCooldown && playerState.dashCharges < playerState.maxDashCharges) {
        playerState.dashCharges++;
        playerState.lastDashTime = now;
    }
    
    playerState.isGrounded = player.contactPoints.ground;
    const onWall = (player.contactPoints.left || player.contactPoints.right);
    playerState.wallSlideDirection = player.contactPoints.left ? -1 : 1;
    
    if (playerState.isGrounded) {
        playerState.jumpsLeft = playerState.maxJumps;
        playerState.isWallSliding = false;
    }

    if (onWall && !playerState.isGrounded && player.body.velocity.y > 0 && !playerState.isDashing) {
        playerState.isWallSliding = true;
        if (player.body.velocity.y > config.player.wallSlideSpeed) {
            Body.setVelocity(player.body, { x: player.body.velocity.x, y: config.player.wallSlideSpeed });
        }
        createParticle(player.body.position.x + (playerState.wallSlideDirection * config.player.width/2), player.body.position.y, '#ccc', 1, 1, 0, 0, 10);
    } else {
        playerState.isWallSliding = false;
    }
}

function playerTakeDamage() {
    if (playerState.isInvincible) return;

    playerState.health--;
    camera.shakeDuration = 20;
    camera.shakeMagnitude = 15;

    if (playerState.health <= 0) {
        gameOver();
    } else {
        playerState.isInvincible = true;
        setTimeout(() => {
            if (!playerState.isDashing) {
                playerState.isInvincible = false;
            }
        }, 1500); 
    }
}


// --- COMBAT & INTERACTION ---
function shoot() {
    const playerPos = player.body.position;
    const mouseWorldX = (mouse.x - mainCanvas.width/2) / camera.zoom + camera.x;
    const mouseWorldY = (mouse.y - mainCanvas.height/2) / camera.zoom + camera.y;

    const angle = Math.atan2(mouseWorldY - playerPos.y, mouseWorldX - playerPos.x);
    const speed = 25;
    
    const projectileBody = Bodies.rectangle(
        playerPos.x + Math.cos(angle) * 30, 
        playerPos.y + Math.sin(angle) * 30, 
        30, 4, {
            label: 'projectile',
            frictionAir: 0,
            friction: 0,
            restitution: 1,
            angle: angle,
            collisionFilter: { group: -1 }
        }
    );
    
    const p = {
        body: projectileBody,
        life: 120,
        bounces: playerState.lanceBounces,
    };
    
    Body.setVelocity(p.body, { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed });
    
    projectiles.push(p);
    World.add(world, p.body);
    
    setTimeout(() => {
        if(p.body) p.body.collisionFilter.group = 0;
    }, 100);
}

function updateProjectiles() {
    for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        p.life--;
        if (p.life <= 0 || p.body.position.y > config.world.height + 50) {
            if (p.body) World.remove(world, p.body);
            projectiles.splice(i, 1);
        }
    }
}


// --- ENEMIES ---
function createEnemy(x, y, type) {
    if (type !== 'flyer') return;

    const size = 35;
    const body = Bodies.polygon(x, y, 6, size / 1.5, {
        label: 'enemy',
        frictionAir: 0.04,
        restitution: 0.8
    });

    const enemy = {
        type: 'flyer',
        body: body,
        size: size,
        state: 'wandering',
        detectionRadius: 450,
        chaseRadius: 800,
        wanderSpeed: 1,
        chaseSpeed: 3.5,
        wanderTarget: null,
        stateTimer: 0
    };

    enemy.body.parentObject = enemy;
    enemies.push(enemy);
    World.add(world, enemy.body);
}

function updateEnemies(dt) {
    enemies.forEach(enemy => {
        if (!enemy.body || !player || enemy.type !== 'flyer') return;

        Body.applyForce(enemy.body, enemy.body.position, {
            x: 0,
            y: -world.gravity.y * enemy.body.mass
        });

        const playerPos = player.body.position;
        const enemyPos = enemy.body.position;
        const distanceToPlayer = Vector.magnitude(Vector.sub(playerPos, enemyPos));

        if (distanceToPlayer < enemy.detectionRadius && enemy.state !== 'chasing') {
            enemy.state = 'chasing';
            enemy.stateTimer = 0;
        } else if (distanceToPlayer > enemy.chaseRadius && enemy.state === 'chasing') {
            enemy.state = 'wandering';
            enemy.stateTimer = 0;
        }

        enemy.stateTimer -= dt;

        if (enemy.state === 'chasing') {
            const direction = Vector.normalise(Vector.sub(playerPos, enemyPos));
            const force = Vector.mult(direction, 0.005 * enemy.body.mass);
            Body.applyForce(enemy.body, enemyPos, force);

            if (Vector.magnitude(enemy.body.velocity) > enemy.chaseSpeed) {
                Body.setVelocity(enemy.body, Vector.mult(Vector.normalise(enemy.body.velocity), enemy.chaseSpeed));
            }
        } else {
            if (!enemy.wanderTarget || enemy.stateTimer <= 0) {
                const wanderRange = 400;
                enemy.wanderTarget = {
                    x: Math.max(100, Math.min(config.world.width - 100, enemyPos.x + (Math.random() - 0.5) * wanderRange)),
                    y: Math.max(100, Math.min(config.world.height - 200, enemyPos.y + (Math.random() - 0.5) * wanderRange))
                };
                enemy.stateTimer = 4000 + Math.random() * 2000;
            }

            const distanceToTarget = Vector.magnitude(Vector.sub(enemy.wanderTarget, enemyPos));
            if (distanceToTarget > 20) {
                const direction = Vector.normalise(Vector.sub(enemy.wanderTarget, enemyPos));
                const force = Vector.mult(direction, 0.002 * enemy.body.mass);
                Body.applyForce(enemy.body, enemyPos, force);

                if (Vector.magnitude(enemy.body.velocity) > enemy.wanderSpeed) {
                    Body.setVelocity(enemy.body, Vector.mult(Vector.normalise(enemy.body.velocity), enemy.wanderSpeed));
                }
            } else {
                enemy.wanderTarget = null;
            }
        }
        
        if (Vector.magnitude(enemy.body.velocity) > 0.1) {
            Body.setAngle(enemy.body, Math.atan2(enemy.body.velocity.y, enemy.body.velocity.x));
        }

        if (enemyPos.x < 50 || enemyPos.x > config.world.width - 50 || enemyPos.y < 50 || enemyPos.y > config.world.height - 50) {
            const centerDir = Vector.normalise(Vector.sub({ x: config.world.width / 2, y: config.world.height / 2 }, enemyPos));
            Body.applyForce(enemy.body, enemyPos, Vector.mult(centerDir, 0.005 * enemy.body.mass));
        }
    });
}

function destroyEnemy(enemy, killedByPlayer = false) {
    const index = enemies.indexOf(enemy);
    if (index > -1) {
        for(let i = 0; i < 20; i++) createParticle(enemy.body.position.x, enemy.body.position.y, '#ff0000', 3, 4);
        
        const shardBody = Bodies.polygon(enemy.body.position.x, enemy.body.position.y, 3, 7, { label: 'shard', frictionAir: 0.05 });
        Body.applyForce(shardBody, shardBody.position, {x: (Math.random()-0.5)*0.05, y: -0.1});
        shardBody.parentObject = { body: shardBody };
        shards.push(shardBody.parentObject);
        World.add(world, shardBody);

        if(playerState.enemiesExplodeOnDeath && Math.random() < 0.25) {
            createExplosion(enemy.body.position, 100, 0.1);
        }

        if (killedByPlayer) score += 100;

        World.remove(world, enemy.body);
        enemies.splice(index, 1);
    }
}

// --- UNSTABLE BLOCKS & PHYSICS ---
function createUnstableBlock(x, y, w, h, type) {
    const body = Bodies.rectangle(x, y, w, h, { isStatic: true, label: 'unstable', friction: 0.5 });
    const block = { type, width: w, height: h, body, isTriggered: false, triggerTime: 0 };
    body.parentObject = block;
    unstableBlocks.push(block);
    World.add(world, body);
}

function triggerUnstableBlock(block, projectileBody) {
    if (block.isTriggered) return;
    score += 10;
    
    switch(block.type) {
        case 'fragile':
            block.isTriggered = true;
            Body.setStatic(block.body, false);
            break;
        case 'volatile':
            block.isTriggered = true;
            block.triggerTime = performance.now();
            break;
        case 'kinetic':
            block.isTriggered = true;
            const pulseRadius = 250;
            const pulseForce = 0.5;

            const bodies = Composite.allBodies(world);
            bodies.forEach(b => {
                if (b === block.body || b.isStatic) return;
                const distance = Vector.magnitude(Vector.sub(b.position, block.body.position));
                if (distance < pulseRadius) {
                    const directionToBody = Vector.normalise(Vector.sub(b.position, block.body.position));
                    const force = Vector.mult(directionToBody, pulseForce * (1 - distance / pulseRadius) * (b.mass / 10));
                    Body.applyForce(b, b.position, force);
                }
            });
            
            for (let i = 0; i < 360; i += 10) {
                const angle = i * Math.PI / 180;
                createParticle(block.body.position.x, block.body.position.y, '#f0f', 4, 8, Math.cos(angle), Math.sin(angle), 30);
            }
            setTimeout(() => block.isTriggered = false, 500);
            break;
    }
}

function updateUnstableBlocks() {
    for(let i = unstableBlocks.length - 1; i >= 0; i--) {
        const block = unstableBlocks[i];
        if (block.type === 'volatile' && block.isTriggered) {
            if (performance.now() - block.triggerTime > 1500) {
                createExplosion(block.body.position, 150 * playerState.volatileExplosionSize, 0.2 * playerState.volatileExplosionSize);
                if (block.body) World.remove(world, block.body);
                unstableBlocks.splice(i, 1);
            }
        }
        if (block.body && block.body.position.y > config.world.height + 100) {
            World.remove(world, block.body);
            unstableBlocks.splice(i, 1);
        }
    }
}

function createExplosion(position, radius, force) {
    camera.shakeDuration = 15;
    camera.shakeMagnitude = 10;
    
    for(let i=0; i<50; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 10 + 2;
        createParticle(position.x, position.y, '#ff8c00', Math.random()*4+1, 0, Math.cos(angle) * speed, Math.sin(angle) * speed, 60);
    }

    const bodies = Composite.allBodies(world);
    bodies.forEach(b => {
        if (b.isStatic) return;
        const distance = Vector.magnitude(Vector.sub(b.position, position));
        if (distance < radius) {
            const direction = Vector.normalise(Vector.sub(b.position, position));
            const appliedForce = Vector.mult(direction, force * (1 - distance/radius) * (b.mass / 10));
            Body.applyForce(b, b.position, appliedForce);
            
            if (b.label === 'player-core') playerTakeDamage();
            else if (b.label === 'enemy') destroyEnemy(b.parentObject, true);
            else if (b.label === 'unstable') {
                World.remove(world, b);
                unstableBlocks = unstableBlocks.filter(block => block.body !== b);
            }
        }
    });
}


// --- PROCEDURAL GENERATION ---
function generateSector(sectorNum) {
    const levelWidth = config.world.width;
    const levelHeight = config.world.height;

    addStaticBody(Bodies.rectangle(levelWidth / 2, levelHeight, levelWidth, 100, { isStatic: true }));
    addStaticBody(Bodies.rectangle(0, levelHeight/2, 50, levelHeight, { isStatic: true }));
    addStaticBody(Bodies.rectangle(levelWidth, levelHeight/2, 50, levelHeight, { isStatic: true }));
    addStaticBody(Bodies.rectangle(levelWidth/2, 0, levelWidth, 50, { isStatic: true }));

    let currentX = 200;
    let currentY = levelHeight - 150;
    let path = [{x: currentX, y: currentY}];

    while(currentX < levelWidth - 400) {
        const stepX = 150 + Math.random() * 250;
        const stepY = (Math.random() - 0.6) * 300;
        currentX += stepX;
        currentY = Math.max(200, Math.min(levelHeight - 150, currentY + stepY));
        path.push({x: currentX, y: currentY});
    }

    path.forEach(point => {
        const width = 150 + Math.random() * 150;
        const platform = Bodies.rectangle(point.x, point.y, width, 30, { isStatic: true });
        platform.width = width;
        addStaticBody(platform);

        // --- FIX: Restore enemy spawning on platforms ---
        if (Math.random() < 0.4) {
            createEnemy(point.x, point.y - 80, 'flyer');
        }

        if (Math.random() < 0.1 + sectorNum * 0.05) createUnstableBlock(point.x + Math.random()*50-25, point.y-25, 50, 50, 'volatile');
    });
    
    const numFillers = 25 + sector * 5;
    for(let i=0; i<numFillers; i++) {
        const x = Math.random() * (levelWidth - 200) + 100;
        const y = Math.random() * (levelHeight - 200) + 100;

        if (Math.random() < 0.6) {
             const width = 80 + Math.random() * 100;
             addStaticBody(Bodies.rectangle(x, y, width, 30, { isStatic: true }));
        } else {
            const type = ['fragile', 'volatile', 'kinetic'][Math.floor(Math.random()*3)];
            createUnstableBlock(x, y, 50, 50, type);
        }
    }
    
    const numFloaters = 3 + sector * 2; // Reduced slightly as we now have platform spawns
    for(let i=0; i<numFloaters; i++) {
        const x = Math.random() * (levelWidth - 400) + 200;
        const y = Math.random() * (levelHeight - 600) + 200;
        createEnemy(x, y, 'flyer');
    }
    
    const lastPoint = path[path.length - 1];
    exitPortal = {
        body: Bodies.circle(lastPoint.x, lastPoint.y - 100, 50, {isStatic: true, isSensor: true, label: 'portal'}),
        radius: 50,
    };
    World.add(world, exitPortal.body);
}


function addStaticBody(body) {
    staticBodies.push(body);
    World.add(world, body);
}

// --- ROGUELIKE & GAME FLOW ---
function enterUpgradeScreen() {
    gameState = 'upgrade';
    document.getElementById('upgrade-screen').style.display = 'flex';
    
    const optionsContainer = document.getElementById('upgrade-options');
    optionsContainer.innerHTML = '';
    
    const available = [...allUpgrades];
    for (let i = 0; i < 3; i++) {
        if (available.length === 0) break;
        const randIndex = Math.floor(Math.random() * available.length);
        const upgrade = available.splice(randIndex, 1)[0];
        
        const optionDiv = document.createElement('div');
        optionDiv.className = 'upgrade-option';
        optionDiv.textContent = upgrade.text;
        optionDiv.addEventListener('click', () => selectUpgrade(upgrade), {once: true});
        optionsContainer.appendChild(optionDiv);
    }
}

function selectUpgrade(upgrade) {
    upgrade.apply();
    document.getElementById('upgrade-screen').style.display = 'none';
    
    sector++;
    score += 1000 * sector;
    
    World.clear(world, false);
    enemies = []; projectiles = []; unstableBlocks = []; shards = []; staticBodies = [];
    
    createPlayer(200, config.world.height - 200);
    generateSector(sector);
    
    playerState.dashCharges = playerState.maxDashCharges;
    
    gameState = 'playing';
}

function checkPortalCollision() {
    if (!player || !exitPortal) return;
    const dist = Vector.magnitude(Vector.sub(player.body.position, exitPortal.body.position));
    if (dist < exitPortal.radius) {
        enterUpgradeScreen();
    }
}

function gameOver() {
     if (gameState === 'gameOver') return;
     gameState = 'gameOver';

     document.getElementById('hud').style.display = 'none';
     document.getElementById('dash-cooldown').style.display = 'none';
     
     if (score > bestScore) {
        bestScore = score;
        localStorage.setItem('glitchfall_bestScore', bestScore);
     }
     
     const convertedCurrency = Math.floor(dataShards / 10);
     permanentCurrency = parseInt(permanentCurrency) + convertedCurrency;
     localStorage.setItem('glitchfall_permCurrency', permanentCurrency);
     
     document.getElementById('final-score').textContent = score;
     document.getElementById('best-score').textContent = bestScore;
     document.getElementById('permanent-currency').textContent = permanentCurrency;
     
     document.getElementById('game-over-screen').style.display = 'flex';
     window.addEventListener('keydown', handleRestart);
}

function handleRestart(e) {
    if (e.code === 'KeyR') {
        window.removeEventListener('keydown', handleRestart);
        window.location.reload();
    }
}


// --- COLLISION EVENTS ---
function setupCollisionEvents() {
    Events.on(engine, 'beforeUpdate', (event) => {
        if (!player) return;
        player.contactPoints = { ground: false, left: false, right: false };
    });

    Events.on(engine, 'collisionActive', (event) => {
        if (!player) return;
        event.pairs.forEach(pair => {
            const { bodyA, bodyB } = pair;
            let sensor, other;
            if (bodyA.label.startsWith('player-') && bodyA.isSensor) {
                sensor = bodyA;
                other = bodyB;
            } else if (bodyB.label.startsWith('player-') && bodyB.isSensor) {
                sensor = bodyB;
                other = bodyA;
            } else {
                return; 
            }
            
            const isStaticSurface = other.isStatic || (other.parentObject && other.parentObject.type && !other.parentObject.isTriggered);
            if (isStaticSurface) {
                switch(sensor.label) {
                    case 'player-ground-sensor':
                        player.contactPoints.ground = true;
                        break;
                    case 'player-left-sensor':
                        player.contactPoints.left = true;
                        break;
                    case 'player-right-sensor':
                        player.contactPoints.right = true;
                        break;
                }
            }
        });
    });

    Events.on(engine, 'collisionStart', (event) => {
        event.pairs.forEach(pair => {
            handleCollisionStart(pair.bodyA, pair.bodyB);
            handleCollisionStart(pair.bodyB, pair.bodyA);
        });
    });
}

function handleCollisionStart(a, b) {
    if (!a.label || !b.label) return;

    if (a.label === 'projectile') {
        const pIndex = projectiles.findIndex(pr => pr.body === a);
        if (pIndex === -1) return;
        const p = projectiles[pIndex];

        if (b.label === 'enemy') {
            hitStop(80);
            if (b.parentObject) destroyEnemy(b.parentObject, true);
            if (a) World.remove(world, a);
            projectiles.splice(pIndex, 1);
        } else if (b.label === 'unstable') {
            if (b.parentObject) triggerUnstableBlock(b.parentObject, a);
            if (a) World.remove(world, a);
            projectiles.splice(pIndex, 1);
        } else if (b.isStatic) {
            if (p.bounces > 0) {
                p.bounces--;
            } else {
                if (a) World.remove(world, a);
                projectiles.splice(pIndex, 1);
            }
        }
    }
    
    if (a.label === 'player-core') {
        if (b.label === 'shard') {
            dataShards++;
            score += 10;
            const shardIndex = shards.findIndex(s => s.body === b);
            if (shardIndex > -1) {
                World.remove(world, b);
                shards.splice(shardIndex, 1);
            }
        } else if (b.label === 'enemy' || b.label === 'enemy-projectile') {
            playerTakeDamage();
        }
    }
    
    if (a.label === 'enemy-projectile' && b.isStatic) {
        const pIndex = projectiles.findIndex(pr => pr.body === a);
        if (pIndex > -1) {
            World.remove(world, a);
            projectiles.splice(pIndex, 1);
        }
    }

    if (a.label === 'unstable' && b.label === 'enemy') {
        if (a.velocity && (Math.abs(a.velocity.y) > 1.5 || Math.abs(a.velocity.x) > 1.5)) {
            if (b.parentObject) destroyEnemy(b.parentObject, true);
        }
    }
}


// --- "JUICE" & EFFECTS ---
function updateCamera() {
     if (!player) return;
     
     const targetX = player.body.position.x;
     const targetY = player.body.position.y;
     camera.x += (targetX - camera.x) * config.camera.lerp;
     camera.y += (targetY - camera.y) * config.camera.lerp;

     const speed = Vector.magnitude(player.body.velocity);
     camera.targetZoom = 1.0 - Math.min(speed / 60, 0.2);
     camera.zoom += (camera.targetZoom - camera.zoom) * config.camera.zoomSpeed;
     
     if (gameFrame % 2 === 0) drawBackground();
}

function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        p.size *= 0.98;
        if (p.life <= 0 || p.size < 0.5) {
            particles.splice(i, 1);
        }
    }
}

function createParticle(x, y, color, size, speed, vx = null, vy = null, life = 40) {
    const angle = Math.random() * Math.PI * 2;
    particles.push({
        x, y, color, size,
        vx: vx !== null ? vx * speed : Math.cos(angle) * speed * Math.random(),
        vy: vy !== null ? vy * speed : Math.sin(angle) * speed * Math.random(),
        life: life + Math.random() * (life/2),
        maxLife: life + life/2,
    });
}

function updateShards() {
     if (!player) return;
     shards.forEach(shard => {
        if (!shard.body) return;
        const direction = Vector.sub(player.body.position, shard.body.position);
        if (Vector.magnitude(direction) < 200) {
            Body.applyForce(shard.body, shard.body.position, Vector.mult(Vector.normalise(direction), 0.003));
        }
     });
}

function hitStop(duration) {
     const originalTimeScale = engine.timing.timeScale;
     engine.timing.timeScale = 0.0001;
     setTimeout(() => {
        engine.timing.timeScale = originalTimeScale;
     }, duration);
}

function updateHUD() {
    document.getElementById('score').textContent = score;
    document.getElementById('shards').textContent = dataShards;
    if(playerState) document.getElementById('health').textContent = playerState.health;

    const dashIndicator = document.getElementById('dash-indicator');
    const now = performance.now();
    let cooldownProgress = Math.min((now - playerState.lastDashTime) / config.player.dashCooldown, 1);

    if (playerState.dashCharges === playerState.maxDashCharges) {
        dashIndicator.style.width = '100%';
        dashIndicator.style.backgroundColor = '#00ffff';
    } else if (playerState.dashCharges > 0) {
        dashIndicator.style.width = '100%';
        dashIndicator.style.backgroundColor = '#55aaaa';
    }
    else {
         dashIndicator.style.width = `${cooldownProgress * 100}%`;
         dashIndicator.style.backgroundColor = '#555588';
    }
}


// --- SETUP & START ---
function setupInputListeners() {
    window.addEventListener('keydown', e => {
        keys[e.code] = true;
        onKeyDown(e);
    });
    window.addEventListener('keyup', e => keys[e.code] = false);

    mainCanvas.addEventListener('mousemove', e => {
        const rect = mainCanvas.getBoundingClientRect();
        mouse.x = e.clientX - rect.left;
        mouse.y = e.clientY - rect.top;
    });
    mainCanvas.addEventListener('mousedown', () => {
        mouse.isDown = true;
        onMouseClick();
    });
    mainCanvas.addEventListener('mouseup', () => mouse.isDown = false);
}

function resizeCanvases() {
    mainCanvas.width = gameContainer.clientWidth;
    mainCanvas.height = gameContainer.clientHeight;
    bgCanvas.width = gameContainer.clientWidth;
    bgCanvas.height = gameContainer.clientHeight;
    drawBackground();
}

// --- Let's Go! ---
init();

</script>
</body>
</html>