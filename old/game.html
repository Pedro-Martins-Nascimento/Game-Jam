<!DOCTYPE html>
<html>
<head>
<title>Project: GLITCHFALL [Final Build]</title>
<meta charset="UTF-8">
<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<style>
	body, html {
		margin: 0;
		padding: 0;
		overflow: hidden;
		background-color: #0a0a1a;
		height: 100%;
		width: 100%;
	}

	#game-container {
		position: relative;
		width: 100%;
		height: 100%;
		cursor: crosshair;
	}

	canvas {
		display: block;
		position: absolute;
		top: 0;
		left: 0;
	}

	#background-canvas {
		z-index: 0;
		background-color: #0a0a1a;
	}

	#main-canvas {
		z-index: 1;
		background-color: transparent;
	}

	#hud {
		position: absolute;
		top: 10px;
		left: 10px;
		color: #00ffff;
		font-family: 'Courier New', Courier, monospace;
		font-size: 20px;
		z-index: 2;
		text-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff;
	}

	#dash-cooldown {
		position: absolute;
		bottom: 20px;
		left: 50%;
		transform: translateX(-50%);
		width: 100px;
		height: 20px;
		border: 2px solid #00ffff;
		background-color: rgba(0, 0, 0, 0.5);
		z-index: 2;
	}

	#dash-indicator {
		height: 100%;
		width: 100%;
		background-color: #00ffff;
		transition: width 0.1s linear;
	}

	.game-screen {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		display: flex;
		flex-direction: column;
		justify-content: center;
		align-items: center;
		background-color: rgba(0, 0, 0, 0.8);
		color: #00ffff;
		font-family: 'Courier New', Courier, monospace;
		z-index: 10;
		text-align: center;
		cursor: pointer;
	}

	.game-screen h1 {
		font-size: 4em;
		text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
		margin-bottom: 20px;
	}

	.game-screen p {
		font-size: 1.5em;
	}

	#upgrade-screen .upgrade-option {
		border: 2px solid #00ffff;
		padding: 20px;
		margin: 10px;
		cursor: pointer;
		width: 80%;
		max-width: 500px;
		transition: background-color 0.2s, box-shadow 0.2s;
	}

	#upgrade-screen .upgrade-option:hover {
		background-color: rgba(0, 255, 255, 0.2);
		box-shadow: 0 0 15px #00ffff;
	}
</style>
</head>
<body>
<div id="game-container">
    <canvas id="background-canvas"></canvas>
    <canvas id="main-canvas"></canvas>

    <div id="hud" style="display: none;">
        <div>Score: <span id="score">0</span></div>
        <div>Data Shards: <span id="shards">0</span></div>
        <div>Health: <span id="health">3</span></div>
    </div>

    <div id="dash-cooldown" style="display: none;">
        <div id="dash-indicator"></div>
    </div>

    <div id="start-screen" class="game-screen">
        <h1>PROJECT: GLITCHFALL</h1>
        <p>Click to Begin Run</p>
    </div>

    <div id="upgrade-screen" class="game-screen" style="display: none;">
        <h1>SECTOR COMPLETE</h1>
        <p>Select a Volatile Mod:</p>
        <div id="upgrade-options"></div>
    </div>

    <div id="game-over-screen" class="game-screen" style="display: none;">
        <h1>SYSTEM CRASH!</h1>
        <p>Score: <span id="final-score">0</span></p>
        <p>Best Score: <span id="best-score">0</span></p>
        <p>System Restoration Points: <span id="permanent-currency">0</span></p>
        <p>Press 'R' to Reboot</p>
    </div>

</div>

<script>
// --- Matter.js Aliases ---
const { Engine, Render, Runner, World, Bodies, Body, Events, Composite, Vector, SAT } = Matter;

// --- DOM Elements ---
const gameContainer = document.getElementById('game-container');
const mainCanvas = document.getElementById('main-canvas');
const bgCanvas = document.getElementById('background-canvas');
const mainCtx = mainCanvas.getContext('2d');
const bgCtx = bgCanvas.getContext('2d');

// --- Engine and World ---
let engine, world, runner;

// --- Game Objects ---
let player;
let exitPortal;
let particles = [];
let projectiles = [];
let enemies = [];
let unstableBlocks = [];
let shards = [];
let staticBodies = []; // For optimized rendering

// --- Game State and Config ---
let gameState = 'start'; // 'start', 'playing', 'upgrade', 'gameOver'
let lastTime = 0;
let gameFrame = 0;

const config = {
    player: {
        width: 30,
        height: 55,
        speed: 7,
        airControlFactor: 0.6,
        jumpForce: 13,
        dashSpeed: 20,
        dashDuration: 150, // ms
        dashInvincibilityDuration: 300, // ms
        dashCooldown: 1000, // ms
        wallSlideSpeed: 1.5,
        wallJumpForce: { x: 8, y: 11 },
    },
    world: {
        gravity: 1.2,
        width: 3200, // Adjusted for new map gen
        height: 2400,
    },
    mapgen: {
        // Cellular Automata parameters
        gridWidth: 160, // world.width / 20
        gridHeight: 120, // world.height / 20
        tileSize: 20,
        fillProbability: 0.45,
        simulationSteps: 5,
    },
    camera: {
        lerp: 0.08,
        zoom: 1.0,
        targetZoom: 1.0,
        zoomSpeed: 0.01,
    }
};

// --- Camera and Stats ---
let camera;
let score = 0;
let dataShards = 0;
let sector = 1;
let bestScore = localStorage.getItem('glitchfall_bestScore') || 0;
let permanentCurrency = localStorage.getItem('glitchfall_permCurrency') || 0;

// --- Player Stats & Upgrades ---
let playerState = {
    health: 3,
    maxHealth: 3,
    jumpsLeft: 0,
    dashCharges: 1,
    lastDashTime: 0,
    isDashing: false,
    isInvincible: false,
    isGrounded: false,
    isWallSliding: false,
    wallSlideDirection: 0,
    // Upgrades
    maxJumps: 3,
    maxDashCharges: 1,
    lanceBounces: 0,
    volatileExplosionSize: 1.0,
    strongerWallJumps: 1.0,
    enemiesExplodeOnDeath: false,
};

const allUpgrades = [
    { id: 'lanceBounce', text: 'Data Lance bounces off walls 3 times.', apply: () => playerState.lanceBounces = 3 },
    { id: 'doubleDash', text: 'Gain a second Dash charge.', apply: () => playerState.maxDashCharges = 2 },
    { id: 'bigBoom', text: 'Volatile Block explosions are 50% larger.', apply: () => playerState.volatileExplosionSize = 1.5 },
    { id: 'wallBoost', text: 'Wall-jumps are 30% stronger.', apply: () => playerState.strongerWallJumps = 1.3 },
    { id: 'enemyExplode', text: 'Enemies have a 25% chance to explode on death.', apply: () => playerState.enemiesExplodeOnDeath = true },
    { id: 'quadJump', text: 'Gain an extra mid-air jump.', apply: () => playerState.maxJumps = 4 }
];

// --- Input Handling ---
const keys = {};
const mouse = { x: 0, y: 0, isDown: false };


// --- UTILITY FUNCTIONS ---
function drawBody(ctx, body) {
    const vertices = body.vertices;
    ctx.beginPath();
    ctx.moveTo(vertices[0].x, vertices[0].y);
    for (let j = 1; j < vertices.length; j++) {
        ctx.lineTo(vertices[j].x, vertices[j].y);
    }
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
}

// --- INITIALIZATION ---
function init() {
    engine = Engine.create();
    world = engine.world;
    world.gravity.y = config.world.gravity;
    runner = Runner.create();

    camera = { x: 0, y: 0, zoom: config.camera.zoom, shakeDuration: 0, shakeMagnitude: 0 };

    resizeCanvases();
    window.addEventListener('resize', resizeCanvases);

    setupInputListeners();
    setupCollisionEvents();

    Runner.run(runner, engine);
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);

    document.getElementById('start-screen').addEventListener('click', startGameRun, { once: true });
}

function startGameRun() {
    World.clear(world, false);
    particles = []; projectiles = []; enemies = []; unstableBlocks = []; shards = []; staticBodies = [];

    resetPlayerStatsForNewRun();

    score = 0; dataShards = 0; sector = 1;

    generateSector(sector);

    document.getElementById('hud').style.display = 'block';
    document.getElementById('dash-cooldown').style.display = 'block';
    document.getElementById('start-screen').style.display = 'none';
    document.getElementById('game-over-screen').style.display = 'none';

    gameState = 'playing';
}

function resetPlayerStatsForNewRun() {
    playerState.health = playerState.maxHealth;
    playerState.maxJumps = 3;
    playerState.maxDashCharges = 1;
    playerState.lanceBounces = 0;
    playerState.volatileExplosionSize = 1.0;
    playerState.strongerWallJumps = 1.0;
    playerState.enemiesExplodeOnDeath = false;

    playerState.jumpsLeft = playerState.maxJumps;
    playerState.dashCharges = playerState.maxDashCharges;
    playerState.lastDashTime = 0;
}

// --- MAIN GAME LOOP ---
function gameLoop(currentTime) {
    const deltaTime = (currentTime - lastTime) || (1000 / 60);
    lastTime = currentTime;

    if (gameState === 'playing') {
        handlePlayerInput(deltaTime);
        update(deltaTime);
    }

    updateCamera(deltaTime);
    render(deltaTime);

    gameFrame++;
    requestAnimationFrame(gameLoop);
}

function update(dt) {
    if (!player) return;
    updatePlayerState();
    updateProjectiles(dt);
    updateEnemies(dt);
    updateParticles(dt);
    updateShards(dt);
    updateUnstableBlocks(dt);
    checkPortalCollision();
    checkManualCollisions(); // New collision check for non-physics enemies

    if (player.body.position.y > config.world.height + 200) {
        gameOver();
    }
}


// --- RENDERING ---
function render() {
    mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
    mainCtx.save();

    let camX = camera.x;
    let camY = camera.y;
    if (camera.shakeDuration > 0) {
        camX += (Math.random() - 0.5) * camera.shakeMagnitude;
        camY += (Math.random() - 0.5) * camera.shakeMagnitude;
        camera.shakeDuration--;
    }
    mainCtx.translate(mainCanvas.width / 2, mainCanvas.height / 2);
    mainCtx.scale(camera.zoom, camera.zoom);
    mainCtx.translate(-camX, -camY);

    mainCtx.strokeStyle = '#557';
    mainCtx.fillStyle = '#1a1a2a';
    mainCtx.lineWidth = 2;
    staticBodies.forEach(body => drawBody(mainCtx, body));

    unstableBlocks.forEach(renderUnstableBlock);

    shards.forEach(renderShard);
    projectiles.forEach(renderProjectile);
    enemies.forEach(renderEnemy);
    if(player) renderPlayer();
    if(exitPortal) renderPortal();
    particles.forEach(renderParticle);

    mainCtx.restore();

    updateHUD();
}

function renderPlayer() {
    const pos = player.body.position;
    const w = config.player.width;
    const h = config.player.height;

    mainCtx.save();
    mainCtx.translate(pos.x, pos.y);

    if (playerState.isInvincible) mainCtx.globalAlpha = 0.5 + Math.sin(performance.now() * 0.05) * 0.2;

    mainCtx.fillStyle = '#00ffff';
    mainCtx.shadowColor = '#00ffff';
    mainCtx.shadowBlur = 15;

    mainCtx.fillRect(-w/2, -h/2, w, h);

    mainCtx.restore();

    if (Vector.magnitude(player.body.velocity) > 1) {
         createParticle(pos.x, pos.y, '#00ffff', 2, 1, 0, 0, 20);
    }
}

function renderUnstableBlock(block) {
    const pos = block.body.position;
    const w = block.width;
    const h = block.height;

    mainCtx.save();
    mainCtx.translate(pos.x, pos.y);
    mainCtx.rotate(block.body.angle);

    mainCtx.lineWidth = 2;

    switch(block.type) {
        case 'fragile':
            mainCtx.fillStyle = '#888';
            mainCtx.strokeStyle = '#AAA';
            mainCtx.fillRect(-w/2, -h/2, w, h);
            mainCtx.beginPath();
            mainCtx.moveTo(-w/4, -h/2); mainCtx.lineTo(w/4, h/2);
            mainCtx.moveTo(w/3, -h/3); mainCtx.lineTo(-w/3, h/4);
            mainCtx.strokeStyle = '#444';
            mainCtx.stroke();
            break;
        case 'volatile':
            const pulse = Math.sin(gameFrame * 0.05) * 5 + 5;
            mainCtx.fillStyle = block.isTriggered ? '#ff5500' : '#ffae42';
            mainCtx.strokeStyle = '#ffae42';
            mainCtx.shadowColor = '#ffae42';
            mainCtx.shadowBlur = pulse;
            mainCtx.fillRect(-w/2, -h/2, w, h);
            if (block.isTriggered) {
                const flashAlpha = Math.abs(Math.sin(gameFrame * 0.5));
                mainCtx.fillStyle = `rgba(255, 255, 255, ${flashAlpha})`;
                mainCtx.fillRect(-w/2, -h/2, w, h);
            }
            break;
        case 'kinetic':
            mainCtx.fillStyle = '#8a2be2';
            mainCtx.strokeStyle = '#c07cfc';
            mainCtx.fillRect(-w/2, -h/2, w, h);
            mainCtx.strokeStyle = '#f0f';
            mainCtx.lineWidth = 4;
            for(let i = -1; i <= 1; i+=2) {
                mainCtx.beginPath();
                mainCtx.moveTo(-w/4, i * h/4);
                mainCtx.lineTo(0, 0);
                mainCtx.lineTo(w/4, i * h/4);
                mainCtx.stroke();
            }
            break;
    }
    mainCtx.restore();
}

function renderEnemy(enemy) {
    const pos = enemy.position;
    mainCtx.save();
    mainCtx.translate(pos.x, pos.y);

    let angle = Math.atan2(enemy.velocity.y, enemy.velocity.x);
    mainCtx.rotate(angle);

    let baseColor = '#ff3030';
    if (enemy.state === 'chasing') baseColor = '#ff5555';
    if (enemy.state === 'attacking') baseColor = '#ffffff';

    mainCtx.fillStyle = baseColor;
    mainCtx.strokeStyle = '#ff9999';
    mainCtx.shadowColor = '#ff3333';
    mainCtx.shadowBlur = 10;
    mainCtx.lineWidth = 2;

    // Draw a hexagon manually
    const size = enemy.size / 2;
    mainCtx.beginPath();
    for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 3) * i;
        const x = size * Math.cos(angle);
        const y = size * Math.sin(angle);
        if (i === 0) mainCtx.moveTo(x, y);
        else mainCtx.lineTo(x, y);
    }
    mainCtx.closePath();
    mainCtx.fill();
    mainCtx.stroke();

    mainCtx.restore();
}

function renderProjectile(p) {
    if(p.isEnemy) {
        mainCtx.fillStyle = '#ff8000';
        mainCtx.shadowColor = '#ff8000';
    } else {
        mainCtx.fillStyle = '#90ee90';
        mainCtx.shadowColor = '#90ee90';
    }
    mainCtx.shadowBlur = 10;
    mainCtx.save();
    mainCtx.translate(p.body.position.x, p.body.position.y);
    mainCtx.rotate(p.body.angle);
    mainCtx.fillRect(-p.width/2, -p.height/2, p.width, p.height);
    mainCtx.restore();

    createParticle(p.body.position.x, p.body.position.y, mainCtx.fillStyle, 1, 0.5);
}

function renderParticle(p) {
    mainCtx.fillStyle = p.color;
    mainCtx.globalAlpha = p.life / p.maxLife;
    mainCtx.beginPath();
    mainCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    mainCtx.fill();
    mainCtx.globalAlpha = 1;
}

function renderShard(s) {
    const pos = s.body.position;
    mainCtx.save();
    mainCtx.translate(pos.x, pos.y);
    const pulse = Math.sin(gameFrame * 0.1 + s.body.id) * 0.2 + 0.8;
    mainCtx.scale(pulse, pulse);
    mainCtx.fillStyle = '#00ffff';
    mainCtx.shadowColor = '#00ffff';
    mainCtx.shadowBlur = 10;
    mainCtx.beginPath();
    mainCtx.moveTo(0, -7);
    mainCtx.lineTo(6, 6);
    mainCtx.lineTo(-6, 6);
    mainCtx.closePath();
    mainCtx.fill();
    mainCtx.restore();
}

function renderPortal() {
    const pos = exitPortal.body.position;
    mainCtx.save();
    mainCtx.translate(pos.x, pos.y);
    const size = exitPortal.radius;

    for(let i=0; i < 3; i++) {
        const radius = size * (1 - i*0.2) * (Math.sin(gameFrame * 0.02 + i) * 0.1 + 0.9);
        mainCtx.strokeStyle = `rgba(138, 43, 226, ${1 - i*0.2})`;
        mainCtx.lineWidth = 4 - i;
        mainCtx.beginPath();
        mainCtx.arc(0, 0, radius, 0, Math.PI*2);
        mainCtx.stroke();
    }
    mainCtx.restore();
}

function drawBackground() {
    bgCtx.fillStyle = '#0a0a1a';
    bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
    bgCtx.strokeStyle = 'rgba(0, 255, 255, 0.05)';
    const gridSize = 50;
    const parallaxX = (camera.x * 0.1) % gridSize;
    const parallaxY = (camera.y * 0.1) % gridSize;

    for (let x = -parallaxX; x < bgCanvas.width; x += gridSize) {
        bgCtx.beginPath();
        bgCtx.moveTo(x, 0);
        bgCtx.lineTo(x, bgCanvas.height);
        bgCtx.stroke();
    }
    for (let y = -parallaxY; y < bgCanvas.height; y += gridSize) {
        bgCtx.beginPath();
        bgCtx.moveTo(0, y);
        bgCtx.lineTo(bgCanvas.width, y);
        bgCtx.stroke();
    }
}


// --- PLAYER LOGIC ---
function createPlayer(x, y) {
    const pConfig = config.player;
    const core = Bodies.rectangle(x, y, pConfig.width, pConfig.height, {
        label: 'player-core', inertia: Infinity, friction: 0.05, restitution: 0.1
    });
    const groundSensor = Bodies.rectangle(x, y + pConfig.height / 2, pConfig.width - 4, 10, { isSensor: true, label: 'player-ground-sensor' });
    const leftSensor = Bodies.rectangle(x - pConfig.width / 2, y, 10, pConfig.height - 8, { isSensor: true, label: 'player-left-sensor' });
    const rightSensor = Bodies.rectangle(x + pConfig.width / 2, y, 10, pConfig.height - 8, { isSensor: true, label: 'player-right-sensor' });

    player = {
        body: Body.create({ parts: [core, groundSensor, leftSensor, rightSensor], label: 'player' }),
        groundSensor, leftSensor, rightSensor, core,
        contactPoints: { ground: false, left: false, right: false },
    };
    World.add(world, player.body);
}

function handlePlayerInput() {
    if (!player) return;

    let targetVelX = 0;
    if (keys['KeyD'] || keys['ArrowRight']) targetVelX = config.player.speed;
    if (keys['KeyA'] || keys['ArrowLeft']) targetVelX = -config.player.speed;

    const airControl = playerState.isGrounded ? 1 : config.player.airControlFactor;
    const newVelX = player.body.velocity.x + (targetVelX - player.body.velocity.x) * 0.2 * airControl;
    Body.setVelocity(player.body, { x: newVelX, y: player.body.velocity.y });

    if (keys['ShiftLeft'] && !playerState.isDashing) {
        const now = performance.now();
        if (now - playerState.lastDashTime > config.player.dashCooldown && playerState.dashCharges > 0) {
            playerState.isDashing = true;
            playerState.isInvincible = true;
            playerState.lastDashTime = now;
            playerState.dashCharges--;

            let dashDir = targetVelX !== 0 ? Math.sign(targetVelX) : (player.body.velocity.x >= 0 ? 1 : -1);
            if (dashDir === 0) dashDir = 1;

            Body.setVelocity(player.body, { x: config.player.dashSpeed * dashDir, y: 0 });

            for(let i=0; i<20; i++) createParticle(player.body.position.x, player.body.position.y, '#FFFFFF', 3, 2);

            setTimeout(() => {
                playerState.isDashing = false;
                if(player) Body.setVelocity(player.body, { x: player.body.velocity.x * 0.2, y: player.body.velocity.y });
            }, config.player.dashDuration);
            setTimeout(() => playerState.isInvincible = false, config.player.dashInvincibilityDuration);
        }
    }
}

function onKeyDown(e) {
    if (gameState !== 'playing' || !player) return;

    if (e.code === 'Space' || e.code === 'KeyW' || e.code === 'ArrowUp') {
        if (playerState.isWallSliding) {
            const forceX = playerState.wallSlideDirection * config.player.wallJumpForce.x * playerState.strongerWallJumps;
            const forceY = -config.player.wallJumpForce.y * playerState.strongerWallJumps;
            Body.setVelocity(player.body, { x: forceX, y: forceY });
            playerState.jumpsLeft = playerState.maxJumps - 1;
            playerState.isWallSliding = false;
            for(let i=0; i<15; i++) createParticle(player.body.position.x, player.body.position.y, '#00ffff', 4, 3);
        } else if (playerState.jumpsLeft > 0) {
            Body.setVelocity(player.body, { x: player.body.velocity.x, y: -config.player.jumpForce });
            playerState.jumpsLeft--;
            for(let i=0; i<10; i++) createParticle(player.body.position.x, player.body.position.y, '#00ffff', 3, 2);
        }
    }
}

function onMouseClick() {
     if (gameState === 'playing' && player) {
        shoot();
     }
}

function updatePlayerState() {
    const now = performance.now();

    if (now - playerState.lastDashTime > config.player.dashCooldown && playerState.dashCharges < playerState.maxDashCharges) {
        playerState.dashCharges++;
        playerState.lastDashTime = now;
    }

    playerState.isGrounded = player.contactPoints.ground;
    const onWall = (player.contactPoints.left || player.contactPoints.right);
    playerState.wallSlideDirection = player.contactPoints.left ? -1 : 1;

    if (playerState.isGrounded) {
        playerState.jumpsLeft = playerState.maxJumps;
        playerState.isWallSliding = false;
    }

    if (onWall && !playerState.isGrounded && player.body.velocity.y > 0 && !playerState.isDashing) {
        playerState.isWallSliding = true;
        if (player.body.velocity.y > config.player.wallSlideSpeed) {
            Body.setVelocity(player.body, { x: player.body.velocity.x, y: config.player.wallSlideSpeed });
        }
        createParticle(player.body.position.x + (playerState.wallSlideDirection * config.player.width/2), player.body.position.y, '#ccc', 1, 1, 0, 0, 10);
    } else {
        playerState.isWallSliding = false;
    }
}

function playerTakeDamage() {
    if (playerState.isInvincible) return;

    playerState.health--;
    camera.shakeDuration = 20;
    camera.shakeMagnitude = 15;

    if (playerState.health <= 0) {
        gameOver();
    } else {
        playerState.isInvincible = true;
        setTimeout(() => {
            if (!playerState.isDashing) {
                playerState.isInvincible = false;
            }
        }, 1500);
    }
}


// --- COMBAT & INTERACTION ---
function shoot() {
    const playerPos = player.body.position;
    const mouseWorldX = (mouse.x - mainCanvas.width/2) / camera.zoom + camera.x;
    const mouseWorldY = (mouse.y - mainCanvas.height/2) / camera.zoom + camera.y;

    const angle = Math.atan2(mouseWorldY - playerPos.y, mouseWorldX - playerPos.x);
    const speed = 25;

    const projectileBody = Bodies.rectangle(
        playerPos.x + Math.cos(angle) * 30,
        playerPos.y + Math.sin(angle) * 30,
        30, 4, {
            label: 'projectile', frictionAir: 0, friction: 0, restitution: 1, angle: angle,
            collisionFilter: { group: -1 }
        }
    );

    projectiles.push({
        body: projectileBody, life: 120, bounces: playerState.lanceBounces, isEnemy: false, width: 30, height: 4
    });

    Body.setVelocity(projectileBody, { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed });
    World.add(world, projectileBody);

    setTimeout(() => {
        if(projectileBody) projectileBody.collisionFilter.group = 0;
    }, 100);
}

function enemyShoot(enemy) {
    if (!player) return;
    const enemyPos = enemy.position;
    const playerPos = player.body.position;

    const angle = Math.atan2(playerPos.y - enemyPos.y, playerPos.x - enemyPos.x);
    const speed = 15;
    const pWidth = 20, pHeight = 8;

    const projectileBody = Bodies.rectangle(
        enemyPos.x + Math.cos(angle) * 40,
        enemyPos.y + Math.sin(angle) * 40,
        pWidth, pHeight, {
            label: 'enemy-projectile', frictionAir: 0, friction: 0, angle: angle
        }
    );

    projectiles.push({
        body: projectileBody, life: 180, isEnemy: true, width: pWidth, height: pHeight
    });

    Body.setVelocity(projectileBody, { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed });
    World.add(world, projectileBody);
}

function updateProjectiles() {
    for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        p.life--;
        if (p.life <= 0 || p.body.position.y > config.world.height + 50) {
            if (p.body) World.remove(world, p.body);
            projectiles.splice(i, 1);
        }
    }
}


// --- NON-PHYSICS ENEMY ---
function createEnemy(x, y) {
    const enemy = {
        id: Math.random(),
        position: { x, y },
        velocity: { x: 0, y: 0 },
        size: 35,
        type: 'sentry',
        state: 'wandering',
        detectionRadius: 500,
        attackRadius: 450,
        chaseRadius: 900,
        wanderSpeed: 1.5,
        chaseSpeed: 3.0,
        wanderTarget: null,
        stateTimer: 0,
        shootCooldown: 2000,
        lastShot: 0
    };
    enemies.push(enemy);
}

function updateEnemies(dt) {
    enemies.forEach(enemy => {
        if (!player) return;

        const playerPos = player.body.position;
        const enemyPos = enemy.position;
        const distanceToPlayer = Vector.magnitude(Vector.sub(playerPos, enemyPos));
        const now = performance.now();

        // State Transitions
        if (enemy.state === 'attacking' && now - enemy.stateTimer > 500) {
            enemy.state = 'chasing';
        } else if (distanceToPlayer < enemy.attackRadius && now - enemy.lastShot > enemy.shootCooldown) {
            enemy.state = 'attacking';
            enemy.stateTimer = now;
            enemy.lastShot = now;
            enemyShoot(enemy);
        } else if (distanceToPlayer < enemy.detectionRadius && enemy.state === 'wandering') {
            enemy.state = 'chasing';
        } else if (distanceToPlayer > enemy.chaseRadius && enemy.state === 'chasing') {
            enemy.state = 'wandering';
        }

        // State Actions - directly manipulate velocity
        switch(enemy.state) {
            case 'chasing': {
                const direction = Vector.normalise(Vector.sub(playerPos, enemyPos));
                enemy.velocity.x = direction.x * enemy.chaseSpeed;
                enemy.velocity.y = direction.y * enemy.chaseSpeed;
                break;
            }
            case 'wandering': {
                if (!enemy.wanderTarget || Vector.magnitude(Vector.sub(enemy.wanderTarget, enemyPos)) < 50) {
                    const wanderRange = 400;
                    enemy.wanderTarget = {
                        x: Math.max(100, Math.min(config.world.width - 100, enemyPos.x + (Math.random() - 0.5) * wanderRange)),
                        y: Math.max(100, Math.min(config.world.height - 200, enemyPos.y + (Math.random() - 0.5) * wanderRange))
                    };
                }
                const direction = Vector.normalise(Vector.sub(enemy.wanderTarget, enemyPos));
                enemy.velocity.x = direction.x * enemy.wanderSpeed;
                enemy.velocity.y = direction.y * enemy.wanderSpeed;
                break;
            }
            case 'attacking': {
                // Stop to shoot
                enemy.velocity.x *= 0.9; // slow down
                enemy.velocity.y *= 0.9;
                break;
            }
        }

        // Update position based on velocity
        enemy.position.x += enemy.velocity.x;
        enemy.position.y += enemy.velocity.y;
    });
}

function destroyEnemy(enemy, killedByPlayer = false) {
    const index = enemies.findIndex(e => e.id === enemy.id);
    if (index > -1) {
        for (let i = 0; i < 20; i++) createParticle(enemy.position.x, enemy.position.y, '#ff0000', 3, 4);

        const shardBody = Bodies.polygon(enemy.position.x, enemy.position.y, 3, 7, { label: 'shard', frictionAir: 0.05 });
        Body.applyForce(shardBody, shardBody.position, {x: (Math.random()-0.5)*0.05, y: -0.1});
        shardBody.parentObject = { body: shardBody };
        shards.push(shardBody.parentObject);
        World.add(world, shardBody);

        if (playerState.enemiesExplodeOnDeath && Math.random() < 0.25) {
            createExplosion(enemy.position, 100, 0.1);
        }

        if (killedByPlayer) score += 100;

        enemies.splice(index, 1);
    }
}

// --- UNSTABLE BLOCKS & PHYSICS ---
function createUnstableBlock(x, y, w, h, type) {
    const body = Bodies.rectangle(x, y, w, h, { isStatic: true, label: 'unstable', friction: 0.5 });
    const block = { type, width: w, height: h, body, isTriggered: false, triggerTime: 0 };
    body.parentObject = block;
    unstableBlocks.push(block);
    World.add(world, body);
}

function triggerUnstableBlock(block) {
    if (block.isTriggered) return;
    score += 10;

    switch(block.type) {
        case 'fragile':
            block.isTriggered = true;
            Body.setStatic(block.body, false);
            break;
        case 'volatile':
            block.isTriggered = true;
            block.triggerTime = performance.now();
            break;
        case 'kinetic':
            block.isTriggered = true;
            const pulseRadius = 250;
            const pulseForce = 0.5;

            Composite.allBodies(world).forEach(b => {
                if (b === block.body || b.isStatic) return;
                const distance = Vector.magnitude(Vector.sub(b.position, block.body.position));
                if (distance < pulseRadius) {
                    const directionToBody = Vector.normalise(Vector.sub(b.position, block.body.position));
                    const force = Vector.mult(directionToBody, pulseForce * (1 - distance / pulseRadius) * (b.mass / 10));
                    Body.applyForce(b, b.position, force);
                }
            });

            for (let i = 0; i < 360; i += 10) {
                const angle = i * Math.PI / 180;
                createParticle(block.body.position.x, block.body.position.y, '#f0f', 4, 8, Math.cos(angle), Math.sin(angle), 30);
            }
            setTimeout(() => block.isTriggered = false, 500);
            break;
    }
}

function updateUnstableBlocks() {
    for(let i = unstableBlocks.length - 1; i >= 0; i--) {
        const block = unstableBlocks[i];
        if (block.type === 'volatile' && block.isTriggered) {
            if (performance.now() - block.triggerTime > 1500) {
                createExplosion(block.body.position, 150 * playerState.volatileExplosionSize, 0.2 * playerState.volatileExplosionSize);
                if (block.body) World.remove(world, block.body);
                unstableBlocks.splice(i, 1);
            }
        }
        if (block.body && block.body.position.y > config.world.height + 100) {
            World.remove(world, block.body);
            unstableBlocks.splice(i, 1);
        }
    }
}

function createExplosion(position, radius, force) {
    camera.shakeDuration = 15;
    camera.shakeMagnitude = 10;

    for(let i=0; i<50; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 10 + 2;
        createParticle(position.x, position.y, '#ff8c00', Math.random()*4+1, 0, Math.cos(angle) * speed, Math.sin(angle) * speed, 60);
    }

    Composite.allBodies(world).forEach(b => {
        if (b.isStatic) return;
        const distance = Vector.magnitude(Vector.sub(b.position, position));
        if (distance < radius) {
            const direction = Vector.normalise(Vector.sub(b.position, position));
            const appliedForce = Vector.mult(direction, force * (1.5 - distance/radius) * (b.mass / 5));
            Body.applyForce(b, b.position, appliedForce);

            if (b.label === 'player-core') playerTakeDamage();
            else if (b.label === 'unstable') {
                World.remove(world, b);
                unstableBlocks = unstableBlocks.filter(block => block.body !== b);
            }
        }
    });

    // Manually check explosion collision with non-physics enemies
    for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        const distance = Vector.magnitude(Vector.sub(enemy.position, position));
        if (distance < radius) {
            destroyEnemy(enemy, true);
        }
    }
}


// --- PROCEDURAL GENERATION (CELLULAR AUTOMATA) ---
function generateSector(sectorNum) {
    const { gridWidth, gridHeight, tileSize, fillProbability, simulationSteps } = config.mapgen;
    let grid = Array(gridHeight).fill(null).map(() => Array(gridWidth).fill(0));

    // 1. Random Initialization
    for (let y = 1; y < gridHeight - 1; y++) {
        for (let x = 1; x < gridWidth - 1; x++) {
            grid[y][x] = Math.random() < fillProbability ? 1 : 0;
        }
    }

    // 2. Cellular Automata Simulation
    for (let i = 0; i < simulationSteps; i++) {
        let newGrid = Array(gridHeight).fill(null).map(() => Array(gridWidth).fill(0));
        for (let y = 1; y < gridHeight - 1; y++) {
            for (let x = 1; x < gridWidth - 1; x++) {
                let neighbors = 0;
                for (let ny = -1; ny <= 1; ny++) {
                    for (let nx = -1; nx <= 1; nx++) {
                        if (ny === 0 && nx === 0) continue;
                        neighbors += grid[y + ny][x + nx];
                    }
                }
                newGrid[y][x] = neighbors > 4 ? 1 : (neighbors < 4 ? 0 : grid[y][x]);
            }
        }
        grid = newGrid;
    }

    // 3. Ensure Borders are Walls
    for(let y=0; y<gridHeight; y++) { grid[y][0] = 1; grid[y][gridWidth-1] = 1; }
    for(let x=0; x<gridWidth; x++) { grid[0][x] = 1; grid[gridHeight-1][x] = 1; }

    // 4. Identify and connect regions to ensure solvability
    const regions = getRegions(grid, 0); // Get all floor regions
    if(regions.length > 1) {
        connectClosestRegions(grid, regions);
    }

    // 5. Create optimized static bodies from grid
    createMapBodies(grid, tileSize);

    // 6. Populate the map
    const floorTiles = [];
    for (let y = 0; y < gridHeight; y++) {
        for (let x = 0; x < gridWidth; x++) {
            if (grid[y][x] === 0) {
                floorTiles.push({x, y}); // Store grid coordinates
            }
        }
    }

    const mainRegion = (regions.length > 0 ? regions[0] : floorTiles);

    // Player spawn
    const playerGridPos = mainRegion[Math.floor(Math.random() * mainRegion.length)];
    const playerWorldPos = {
        x: playerGridPos.x * tileSize + tileSize / 2,
        y: playerGridPos.y * tileSize + tileSize / 2
    };
    createPlayer(playerWorldPos.x, playerWorldPos.y);

    // Exit Portal spawn - far from the player
    let bestPortalGridPos = null, maxDistSq = 0;
    for(const candidateGridPos of mainRegion) {
        const distSq = Math.pow(candidateGridPos.x - playerGridPos.x, 2) + Math.pow(candidateGridPos.y - playerGridPos.y, 2);
        if (distSq > maxDistSq) {
            maxDistSq = distSq;
            bestPortalGridPos = candidateGridPos;
        }
    }
    if (!bestPortalGridPos) bestPortalGridPos = mainRegion[mainRegion.length - 1];
    const portalWorldPos = {
        x: bestPortalGridPos.x * tileSize + tileSize / 2,
        y: bestPortalGridPos.y * tileSize + tileSize / 2
    };
    exitPortal = {
        body: Bodies.circle(portalWorldPos.x, portalWorldPos.y, 50, {isStatic: true, isSensor: true, label: 'portal'}),
        radius: 50,
    };
    World.add(world, exitPortal.body);

    const safeSpawnRadius = 15;
    const safeTiles = floorTiles.filter(tile => {
        const distSq = Math.pow(tile.x - playerGridPos.x, 2) + Math.pow(tile.y - playerGridPos.y, 2);
        return distSq > safeSpawnRadius * safeSpawnRadius;
    });

    const numEnemies = 20 + sector * 2; // Increased enemy count
    for (let i = 0; i < numEnemies && safeTiles.length > 0; i++) {
        const randIndex = Math.floor(Math.random() * safeTiles.length);
        const pos = safeTiles.splice(randIndex, 1)[0];
        createEnemy(pos.x * tileSize + tileSize / 2, pos.y * tileSize + tileSize / 2);
    }
    const numBlocks = 15 + sector * 3;
    for (let i = 0; i < numBlocks && safeTiles.length > 0; i++) {
        const randIndex = Math.floor(Math.random() * safeTiles.length);
        const pos = safeTiles.splice(randIndex, 1)[0];
        const type = ['fragile', 'volatile', 'kinetic'][Math.floor(Math.random()*3)];
        createUnstableBlock(pos.x * tileSize + tileSize / 2, pos.y * tileSize + tileSize / 2, 50, 50, type);
    }
}

function getRegions(grid, tileType) {
    const regions = [];
    const visited = new Set();
    for (let y = 0; y < grid.length; y++) {
        for (let x = 0; x < grid[0].length; x++) {
            const posKey = `${x},${y}`;
            if (grid[y][x] === tileType && !visited.has(posKey)) {
                const newRegion = [];
                const queue = [{x, y}];
                visited.add(posKey);
                while(queue.length > 0) {
                    const tile = queue.shift();
                    newRegion.push(tile);
                    for(let ny = -1; ny <= 1; ny++) {
                        for(let nx = -1; nx <= 1; nx++) {
                            if(Math.abs(nx) === Math.abs(ny)) continue;
                            const checkX = tile.x + nx;
                            const checkY = tile.y + ny;
                            if(checkX >= 0 && checkX < grid[0].length && checkY >= 0 && checkY < grid.length) {
                                const neighborKey = `${checkX},${checkY}`;
                                if(grid[checkY][checkX] === tileType && !visited.has(neighborKey)) {
                                    visited.add(neighborKey);
                                    queue.push({x: checkX, y: checkY});
                                }
                            }
                        }
                    }
                }
                regions.push(newRegion);
            }
        }
    }
    return regions;
}

function connectClosestRegions(grid, regions) {
    while (regions.length > 1) {
        let bestDist = Infinity;
        let bestTileA = null, bestTileB = null;
        let bestRegionIndexA = -1, bestRegionIndexB = -1;

        for (let i = 0; i < regions.length; i++) {
            for (let j = i + 1; j < regions.length; j++) {
                for (const tileA of regions[i]) {
                    for (const tileB of regions[j]) {
                        const distSq = Math.pow(tileA.x - tileB.x, 2) + Math.pow(tileA.y - tileB.y, 2);
                        if (distSq < bestDist) {
                            bestDist = distSq;
                            bestTileA = tileA; bestTileB = tileB;
                            bestRegionIndexA = i; bestRegionIndexB = j;
                        }
                    }
                }
            }
        }

        let line = getLine(bestTileA, bestTileB);
        for(const point of line) {
            for(let y = -1; y <= 1; y++) {
                for(let x = -1; x <= 1; x++) {
                    const carveX = point.x + x;
                    const carveY = point.y + y;
                    if (grid[carveY] && grid[carveY][carveX] !== undefined) {
                        grid[carveY][carveX] = 0;
                    }
                }
            }
        }

        regions[bestRegionIndexA].push(...regions.splice(bestRegionIndexB, 1)[0]);
    }
}

function getLine(from, to) {
    const line = [];
    let x = from.x, y = from.y;
    const dx = to.x - from.x, dy = to.y - from.y;
    const step = Math.sign(dx), gradientStep = Math.sign(dy);
    let longest = Math.abs(dx), shortest = Math.abs(dy);
    let inverted = false;
    if (longest < shortest) {
        inverted = true;
        [longest, shortest] = [shortest, longest];
    }
    let gradientAccumulation = longest / 2;
    for(let i=0; i<longest; i++) {
        line.push({x,y});
        if (inverted) y += gradientStep; else x += step;
        gradientAccumulation += shortest;
        if(gradientAccumulation >= longest) {
            if(inverted) x += step; else y += gradientStep;
            gradientAccumulation -= longest;
        }
    }
    return line;
}

function createMapBodies(grid, tileSize) {
    const visited = new Set();
    for (let y = 0; y < grid.length; y++) {
        for (let x = 0; x < grid[0].length; x++) {
            if (grid[y][x] === 1 && !visited.has(`${x},${y}`)) {
                let currentW = 1;
                while (x + currentW < grid[0].length && grid[y][x + currentW] === 1 && !visited.has(`${x+currentW},${y}`)) {
                    currentW++;
                }
                let currentH = 1;
                let canExpandH = true;
                while (y + currentH < grid.length && canExpandH) {
                    for (let i = 0; i < currentW; i++) {
                        if (grid[y + currentH][x + i] !== 1 || visited.has(`${x+i},${y+currentH}`)) {
                            canExpandH = false;
                            break;
                        }
                    }
                    if (canExpandH) currentH++;
                }
                for (let h = 0; h < currentH; h++) {
                    for (let w = 0; w < currentW; w++) {
                        visited.add(`${x + w},${y + h}`);
                    }
                }
                const bodyX = (x + currentW / 2) * tileSize;
                const bodyY = (y + currentH / 2) * tileSize;
                const bodyW = currentW * tileSize;
                const bodyH = currentH * tileSize;
                addStaticBody(Bodies.rectangle(bodyX, bodyY, bodyW, bodyH, { isStatic: true, friction: 0.5 }));
            }
        }
    }
}

function addStaticBody(body) {
    staticBodies.push(body);
    World.add(world, body);
}

// --- ROGUELIKE & GAME FLOW ---
function enterUpgradeScreen() {
    gameState = 'upgrade';
    document.getElementById('upgrade-screen').style.display = 'flex';

    const optionsContainer = document.getElementById('upgrade-options');
    optionsContainer.innerHTML = '';

    const available = [...allUpgrades];
    for (let i = 0; i < 3; i++) {
        if (available.length === 0) break;
        const randIndex = Math.floor(Math.random() * available.length);
        const upgrade = available.splice(randIndex, 1)[0];

        const optionDiv = document.createElement('div');
        optionDiv.className = 'upgrade-option';
        optionDiv.textContent = upgrade.text;
        optionDiv.addEventListener('click', () => selectUpgrade(upgrade), {once: true});
        optionsContainer.appendChild(optionDiv);
    }
}

function selectUpgrade(upgrade) {
    upgrade.apply();
    document.getElementById('upgrade-screen').style.display = 'none';

    sector++;
    score += 1000 * sector;

    World.clear(world, false);
    enemies = []; projectiles = []; unstableBlocks = []; shards = []; staticBodies = [];

    generateSector(sector);

    playerState.dashCharges = playerState.maxDashCharges;

    gameState = 'playing';
}

function checkPortalCollision() {
    if (!player || !exitPortal) return;
    const dist = Vector.magnitude(Vector.sub(player.body.position, exitPortal.body.position));
    if (dist < exitPortal.radius) {
        enterUpgradeScreen();
    }
}

function gameOver() {
     if (gameState === 'gameOver') return;
     gameState = 'gameOver';

     document.getElementById('hud').style.display = 'none';
     document.getElementById('dash-cooldown').style.display = 'none';

     if (score > bestScore) {
        bestScore = score;
        localStorage.setItem('glitchfall_bestScore', bestScore);
     }

     const convertedCurrency = Math.floor(dataShards / 10);
     permanentCurrency = parseInt(permanentCurrency) + convertedCurrency;
     localStorage.setItem('glitchfall_permCurrency', permanentCurrency);

     document.getElementById('final-score').textContent = score;
     document.getElementById('best-score').textContent = bestScore;
     document.getElementById('permanent-currency').textContent = permanentCurrency;

     document.getElementById('game-over-screen').style.display = 'flex';
     window.addEventListener('keydown', handleRestart);
}

function handleRestart(e) {
    if (e.code === 'KeyR') {
        window.removeEventListener('keydown', handleRestart);
        window.location.reload();
    }
}


// --- COLLISION EVENTS ---
function setupCollisionEvents() {
    Events.on(engine, 'beforeUpdate', () => {
        if (!player) return;
        player.contactPoints = { ground: false, left: false, right: false };
    });

    Events.on(engine, 'collisionActive', (event) => {
        if (!player) return;
        event.pairs.forEach(pair => {
            let sensor, other;
            if (pair.bodyA.label.startsWith('player-') && pair.bodyA.isSensor) { sensor = pair.bodyA; other = pair.bodyB; }
            else if (pair.bodyB.label.startsWith('player-') && pair.bodyB.isSensor) { sensor = pair.bodyB; other = pair.bodyA; }
            else { return; }

            if (other.isStatic || (other.parentObject && other.parentObject.type && !other.parentObject.isTriggered)) {
                if (sensor.label === 'player-ground-sensor') player.contactPoints.ground = true;
                else if (sensor.label === 'player-left-sensor') player.contactPoints.left = true;
                else if (sensor.label === 'player-right-sensor') player.contactPoints.right = true;
            }
        });
    });

    Events.on(engine, 'collisionStart', (event) => {
        event.pairs.forEach(pair => {
            handleCollisionStart(pair.bodyA, pair.bodyB);
            handleCollisionStart(pair.bodyB, pair.bodyA);
        });
    });
}

function checkManualCollisions() {
    if (!player) return;
    const playerPos = player.body.position;

    for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];

        // Player -> Enemy Collision
        const distToPlayer = Vector.magnitude(Vector.sub(playerPos, enemy.position));
        if (distToPlayer < (enemy.size / 2 + config.player.width / 2)) {
            playerTakeDamage();
        }

        // Projectile -> Enemy Collision
        for (let j = projectiles.length - 1; j >= 0; j--) {
            const p = projectiles[j];
            if (p.isEnemy) continue;

            const distToProjectile = Vector.magnitude(Vector.sub(p.body.position, enemy.position));
            if (distToProjectile < enemy.size / 2) {
                destroyEnemy(enemy, true);
                if (p.body) World.remove(world, p.body);
                projectiles.splice(j, 1);
                break; // Move to next enemy once this one is destroyed
            }
        }
    }
}

function handleCollisionStart(a, b) {
    if (!a.label || !b.label) return;

    // Handle projectile collisions with things that ARE in the physics world
    if (a.label === 'projectile' || a.label === 'enemy-projectile') {
        const pIndex = projectiles.findIndex(pr => pr.body === a);
        if (pIndex === -1) return;
        const p = projectiles[pIndex];
        let shouldRemove = true;

        if (b.label === 'unstable' && !p.isEnemy) {
            if (b.parentObject) triggerUnstableBlock(b.parentObject);
        } else if (b.label === 'player-core' && p.isEnemy) {
            playerTakeDamage();
        } else if (b.isStatic && !p.isEnemy && p.bounces > 0) {
            p.bounces--;
            shouldRemove = false;
        } else if (!b.isStatic) { // if it hit something dynamic, don't remove unless we need to
            shouldRemove = false;
        }

        if (shouldRemove) {
            if (a) World.remove(world, a);
            projectiles.splice(pIndex, 1);
        }
    }

    if (a.label === 'player-core') {
        if (b.label === 'shard') {
            dataShards++; score += 10;
            const shardIndex = shards.findIndex(s => s.body === b);
            if (shardIndex > -1) { World.remove(world, b); shards.splice(shardIndex, 1); }
        }
    }
}


// --- "JUICE" & EFFECTS ---
function updateCamera() {
     if (!player) return;

     const targetX = player.body.position.x;
     const targetY = player.body.position.y;
     camera.x += (targetX - camera.x) * config.camera.lerp;
     camera.y += (targetY - camera.y) * config.camera.lerp;

     const speed = Vector.magnitude(player.body.velocity);
     camera.targetZoom = 1.0 - Math.min(speed / 60, 0.2);
     camera.zoom += (camera.targetZoom - camera.zoom) * config.camera.zoomSpeed;

     if (gameFrame % 2 === 0) drawBackground();
}

function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx; p.y += p.vy; p.life--; p.size *= 0.98;
        if (p.life <= 0 || p.size < 0.5) { particles.splice(i, 1); }
    }
}

function createParticle(x, y, color, size, speed, vx = null, vy = null, life = 40) {
    const angle = Math.random() * Math.PI * 2;
    particles.push({
        x, y, color, size,
        vx: vx !== null ? vx * speed : Math.cos(angle) * speed * Math.random(),
        vy: vy !== null ? vy * speed : Math.sin(angle) * speed * Math.random(),
        life: life + Math.random() * (life/2),
        maxLife: life + life/2,
    });
}

function updateShards() {
     if (!player) return;
     shards.forEach(shard => {
        if (!shard.body) return;
        const direction = Vector.sub(player.body.position, shard.body.position);
        if (Vector.magnitude(direction) < 200) {
            Body.applyForce(shard.body, shard.body.position, Vector.mult(Vector.normalise(direction), 0.003));
        }
     });
}

function hitStop(duration) {
     const originalTimeScale = engine.timing.timeScale;
     engine.timing.timeScale = 0.0001;
     setTimeout(() => { engine.timing.timeScale = originalTimeScale; }, duration);
}

function updateHUD() {
    document.getElementById('score').textContent = score;
    document.getElementById('shards').textContent = dataShards;
    if(playerState) document.getElementById('health').textContent = playerState.health;

    const dashIndicator = document.getElementById('dash-indicator');
    const now = performance.now();
    let cooldownProgress = Math.min((now - playerState.lastDashTime) / config.player.dashCooldown, 1);

    if (playerState.dashCharges === playerState.maxDashCharges) {
        dashIndicator.style.width = '100%';
        dashIndicator.style.backgroundColor = '#00ffff';
    } else if (playerState.dashCharges > 0) {
        dashIndicator.style.width = '100%';
        dashIndicator.style.backgroundColor = '#55aaaa';
    }
    else {
         dashIndicator.style.width = `${cooldownProgress * 100}%`;
         dashIndicator.style.backgroundColor = '#555588';
    }
}


// --- SETUP & START ---
function setupInputListeners() {
    window.addEventListener('keydown', e => { keys[e.code] = true; onKeyDown(e); });
    window.addEventListener('keyup', e => keys[e.code] = false);

    mainCanvas.addEventListener('mousemove', e => {
        const rect = mainCanvas.getBoundingClientRect();
        mouse.x = e.clientX - rect.left;
        mouse.y = e.clientY - rect.top;
    });
    mainCanvas.addEventListener('mousedown', () => { mouse.isDown = true; onMouseClick(); });
    mainCanvas.addEventListener('mouseup', () => mouse.isDown = false);
}

function resizeCanvases() {
    mainCanvas.width = gameContainer.clientWidth;
    mainCanvas.height = gameContainer.clientHeight;
    bgCanvas.width = gameContainer.clientWidth;
    bgCanvas.height = gameContainer.clientHeight;
    drawBackground();
}

// --- Let's Go! ---
init();

</script>
</body>
</html>
